<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dickinson Poems</title>
    
    <!-- Import "Cinzel" font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&display=swap" rel="stylesheet">
    
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* This is critical. No scrolling. */
            font-family: 'Cinzel', serif;
            
            /*
              FIX: Re-introduced CSS transitions.
              This is the ONLY way to get a smooth morph on mobile.
              The JS will update the color, and the CSS will animate it.
            */
            --bg-color: hsl(200, 30%, 10%);
            --font-color: hsl(20, 80%, 90%);
            
            background-color: var(--bg-color);
            color: var(--font-color);
            
            /* This is the key to the smooth morph */
            transition: background-color 1.0s linear, color 1.0s linear;
        }
        
        /*
          FIX: This class is added by JS to *disable* the transition
          only for the instant flash.
        */
        body.is-flashing {
            transition: none;
        }

        #poem-container {
            display: grid;
            place-items: center;
            height: 100%;
            text-align: center;
            padding: 2rem;
            box-sizing: border-box;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #stanza-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 900px; /* Max width for longer lines */
        }

        .poem-line {
            /* FIX: Replaced static font-size and @media queries
              with a fluid, dynamic font size using clamp().
              min: 1.25rem (for mobile)
              dynamic: 2.5vw (grows with viewport)
              max: 1.75rem (for desktop)
            */
            font-size: clamp(1.25rem, 2.5vw, 1.75rem);
            
            line-height: 1.6;
            min-height: 1.6em; /* Prevents layout jump */
            opacity: 0;
            transition: opacity 1.2s ease-in-out;
            
            /* FIX: Add 100% width and overflow-wrap
               This forces the text to obey the container and wrap
               if the shrink-to-fit logic fails, finally
               preventing all mobile cutoff.
            */
            width: 100%;
            overflow-wrap: break-word;
            
            /* white-space will be toggled by JS */
        }

        /* Style for the em-dash */
        .poem-line .em-dash {
            font-family: 'Times New Roman', Times, serif;
            font-weight: bold;
        }

        /* Title Overlay for Roman Numeral */
        #poem-title-overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            
            /* Use the same JS-controlled variables */
            background-color: var(--bg-color);
            color: var(--font-color);
            
            z-index: 100;
            opacity: 0;
            pointer-events: none; /* Allows clicks through when hidden */
            
            /* FIX: Overlay must also have the color transitions */
            transition: opacity 1.2s ease-in-out, 
                        background-color 1.0s linear, 
                        color 1.0s linear;
        }
        
        /* FIX: The overlay must *also* have its transition disabled
           during the instant flash. */
        body.is-flashing #poem-title-overlay {
            transition: opacity 1.2s ease-in-out; /* Keep opacity transition */
        }
        
        #poem-title-numeral {
            font-size: clamp(3rem, 10vw, 5rem); /* Dynamic size for title */
            font-weight: 700;
            transform: scale(0.9);
            opacity: 0;
            transition: opacity 1.2s ease-in-out, transform 1.2s ease-in-out;
        }

        #loading {
            font-size: 2rem;
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background-color: #000;
            color: #fff;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            font-family: 'Cinzel', serif;
        }
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Hide the poem container when the title is showing */
        body.showing-title #poem-container {
            opacity: 0;
        }

        /* --- PHASES FOR EFFECTS --- */

        /* Phase 3: Lenticular/Shiny Text */
        @keyframes shine {
            to {
                background-position: -200% center;
            }
        }

        /* Phase 4 Keyframes (Rapid Flicker) */
        @keyframes flicker-bright {
            0%   { filter: brightness(1); }
            5%   { filter: brightness(0.5); }
            10%  { filter: brightness(1); }
            20%  { filter: brightness(1); }
            22%  { filter: brightness(0.3); }
            25%  { filter: brightness(1); }
            50%  { filter: brightness(1); }
            52%  { filter: brightness(0.6); }
            56%  { filter: brightness(1); }
            80%  { filter: brightness(1); }
            83%  { filter: brightness(0.4); }
            88%  { filter: brightness(1); }
            100% { filter: brightness(1); }
        }

        /* Phase 3 & 4: Activated after 15 minutes */
        body.phase-3 .poem-line,
        body.phase-4 .poem-line {
            background-image: linear-gradient(
                -45deg,
                #ff0000, #ff7300, /* #fffb00 removed */ #48ff00,
                #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000
            );
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            
            /* FIX: Stronger, brighter white glow for readability */
            text-shadow: 0 0 8px #fff, 0 0 12px #fff, 0 0 20px #fff;
            
            /* Slowed down 'shine' animation */
            animation: shine 8s linear infinite;
        }
        
        /* Phase 4 (Flicker) stacks on top of Phase 3 */
        body.phase-4 .poem-line {
            /* Stack 'shine' (from P3) with 'flicker-bright' (P4) */
            animation: shine 8s linear infinite, 
                       flicker-bright 0.2s linear infinite;
        }

    </style>
</head>
<body>

    <div id="poem-container">
        <div id="stanza-container">
            <div class="poem-line"></div>
            <div class="poem-line"></div>
            <div class="poem-line"></div>
            <div class="poem-line"></div>
        </div>
    </div>

    <div id="loading">Loading Poems...</div>

    <div id="poem-title-overlay">
        <h1 id="poem-title-numeral"></h1>
    </div>

    <script>
        // --- POEM DATA ---
        let allPoems = [];

        // --- DOM REFERENCES ---
        const stanzaContainer = document.getElementById("stanza-container");
        const lineElements = [
            stanzaContainer.children[0],
            stanzaContainer.children[1],
            stanzaContainer.children[2],
            stanzaContainer.children[3]
        ];
        const body = document.body;
        const titleOverlay = document.getElementById('poem-title-overlay');
        const titleNumeral = document.getElementById('poem-title-numeral');
        const loadingOverlay = document.getElementById('loading');

        // --- STATE VARIABLES ---
        let currentPoem = null;
        let currentStanzaIndex = 0;
        let isFlashing = false; // Phase 2 (flashing)
        let isPhase3 = false;   // Phase 3 (polychrome)
        let flashInterval = 1000;
        let lastFlashTime = 0;
        let flashAccelerationStartTime = 0;
        let isCurrentlyFlashing = false; // Tracks if we are in the 100ms flash

        // --- TIMING CONSTANTS ---
        const LINE_FADE_IN = 1200;
        const LINE_FADE_OUT = 1200;
        const LINE_VISIBLE = 2500;
        const STANZA_DELAY = 1000;
        const POEM_DELAY = 2000;

        const PHASE_2_START_TIME = 5 * 60 * 1000;  // 5 minutes
        const FLASH_ACCELERATION_DURATION = 10 * 60 * 1000; // 10 minutes (5m -> 15m)
        const FLASH_INTERVAL_START = 1000; // 1 flash per second
        const FLASH_INTERVAL_END = 100;    // 10 flashes per second
        
        // Both P3 and P4 start at 15 minutes
        const PHASE_3_START_TIME = 15 * 60 * 1000; // 15 minutes (Polychrome)
        const PHASE_4_START_TIME = 15 * 60 * 1000; // 15 minutes (Flicker)

        // The duration of the hard flash
        const FLASH_DURATION = 100; // 100ms

        // Title Flash Timing
        const TIME_TITLE_FADE_IN = 1200;
        const TIME_TITLE_VISIBLE = 2000;
        const TIME_TITLE_FADE_OUT = 1200;

        // --- POEM DISPLAY LOGIC ---

        /**
         * Fetches and parses the poems.txt file.
         */
        async function loadAndParsePoems() {
            try {
                // This URL must be the GitHub Pages URL, not the raw.github... URL
                const poemsUrl = 'https://MTvrimPossible.github.io/dickinson/dickinson.txt';
                
                console.log(`Attempting to fetch poems from: ${poemsUrl}`);

                const response = await fetch(poemsUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                console.log("--- RAW TEXT FILE CONTENT ---");
                // console.log(text); // Uncomment for debugging
                console.log("--- END RAW TEXT ---");

                // Normalize all line endings (Windows/Mac/Unix) to just \n
                // Add newlines at the start to catch the very first poem
                const normalizedText = "\n\n" + text.replace(/\r\n/g, '\n');

                // Split the file by the Roman numeral headers.
                // It looks for (any newline)(Roman numeral)(.)(any newline)
                // This is much more robust.
                const parts = normalizedText.split(/\n\n([IVXLCDM]+)\.\n\n/);
                
                // Process the parts into the poem structure
                for (let i = 1; i < parts.length; i += 2) {
                    const title = parts[i];       // This is the Roman numeral, e.g., "XX"
                    const poemText = parts[i + 1];  // This is the poem text

                    if (!poemText) continue;

                    // Process the poem text into lines and stanzas
                    const lines = poemText.split('\n')
                        .map(line => line.trim()) // Trim whitespace from each line
                        .filter(line => line.length > 0); // Remove empty lines

                    const stanzas = [];
                    for (let j = 0; j < lines.length; j += 4) {
                        // Slice 4 lines for the stanza.
                        stanzas.push(lines.slice(j, j + 4));
                    }

                    if (stanzas.length > 0) {
                        allPoems.push({
                            title: title, // e.g., "I" or "XXI"
                            stanzas: stanzas
                        });
                    }
                }
                
                if (allPoems.length === 0) {
                    throw new Error("No poems were successfully parsed. Check file format.");
                }
                
                console.log(`Successfully loaded and parsed ${allPoems.length} poems.`);
                
            } catch (error) {
                console.error("Failed to load or parse poems:", error.message, error);
                loadingOverlay.textContent = "Error loading poems. Please try again.";
            }
        }


        /**
         * Starts the poem display sequence.
         * Picks a new random poem and starts from the first stanza.
         */
        async function startNewPoem() {
            // Pick a random poem that isn't the same as the last one
            let newPoem;
            do {
                newPoem = allPoems[Math.floor(Math.random() * allPoems.length)];
            } while (newPoem === currentPoem && allPoems.length > 1);
            
            currentPoem = newPoem;
            currentStanzaIndex = 0;
            
            // Wait for the title to display *before* showing the stanza
            await displayPoemTitle(currentPoem.title);
            
            showStanza(currentStanzaIndex);
        }

        /**
         * Displays the poem title/number overlay
         * @param {string} titleString - The title from the poem object (which is just the numeral)
         */
        async function displayPoemTitle(titleString) {
            // Set text
            titleNumeral.textContent = titleString; 
            
            // Show overlay with fade-in
            body.classList.add('showing-title');
            titleOverlay.style.pointerEvents = 'auto';
            titleOverlay.style.opacity = 1;

            // Animate title numeral (scale and fade-in)
            await wait(100); // Short delay for CSS
            titleNumeral.style.opacity = 1;
            titleNumeral.style.transform = 'scale(1)';

            // Hold
            await wait(TIME_TITLE_VISIBLE);

            // Fade out the entire overlay
            titleOverlay.style.opacity = 0;
            titleNumeral.style.opacity = 0; // Fade out numeral as well
            titleNumeral.style.transform = 'scale(0.9)'; // Scale numeral back down
            
            await wait(TIME_TITLE_FADE_OUT); // Wait for the fade-out transition to complete
            
            // Hide overlay, show poem
            body.classList.remove('showing-title');
            titleOverlay.style.pointerEvents = 'none';
        }

        /**
         * Displays a single stanza, line by line.
         */
        async function showStanza(stanzaIndex) {
            const stanza = currentPoem.stanzas[stanzaIndex];
            
            for (let i = 0; i < 4; i++) {
                const line = stanza[i] || ""; // Get line or empty string
                const el = lineElements[i];
                
                // --- Font shrinking/wrapping logic ---
                
                // 1. Reset font size and white-space
                el.style.fontSize = ''; 
                el.style.whiteSpace = 'nowrap'; // Force one line to measure
                
                // 2. Set new line content
                const processedLine = line.replace(/\s*-\s*/g, '<span class="em-dash">—</span>');
                el.innerHTML = processedLine; // Use innerHTML to render the span

                // 3. Get container width
                const containerWidth = stanzaContainer.clientWidth;

                // 4. Check for overflow
                if (el.scrollWidth > containerWidth) {
                    // 5. Calculate and apply new font size
                    const defaultFontSize = parseFloat(window.getComputedStyle(el).fontSize);
                    const ratio = containerWidth / el.scrollWidth;
                    // No min font size; shrink as small as needed.
                    const newFontSize = Math.floor(defaultFontSize * ratio); 
                    el.style.fontSize = `${newFontSize}px`;
                }

                // 6. Check *again* after shrinking. If still overflowing, wrap.
                if (el.scrollWidth > containerWidth) {
                    el.style.whiteSpace = 'normal'; // Allow wrapping as fallback
                }
                // --- End of new logic ---
                
                // Fade In
                el.style.opacity = 1;
                await wait(LINE_VISIBLE);
                
                // Fade Out
                el.style.opacity = 0;
                await wait(LINE_FADE_OUT);
            }

            // After all lines are done, check for next stanza or poem
            await wait(STANZA_DELAY);

            if (currentStanzaIndex < currentPoem.stanzas.length - 1) {
                // Go to next stanza
                currentStanzaIndex++;
                showStanza(currentStanzaIndex);
            } else {
                // End of poem, start a new one
                await wait(POEM_DELAY);
                startNewPoem();
            }
        }
        
        // Helper function for delays
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- COLOR & EFFECT LOGIC ---
        
        /*
          FIX: This is the new, robust logic.
          1. A 'morphColors' loop (setTimeout) sets the color targets.
          2. CSS 'transition' (1.0s) handles the smooth animation.
          3. A 'flashLoop' (setTimeout) interrupts by adding a class
             that sets 'transition: none' for an instant flash.
        */

        let hue = 200; // Starting hue
        let bgLight = 10;
        let fontLight = 90;
        let bgSat = 30;
        let fontSat = 80;
        const flashHueJump = 180; // Color-wheel opposite

        /**
         * This function runs every 1 second to set the *next*
         * color target. The CSS transition handles the smooth
         * animation *between* these 1-second steps.
         */
        function morphColors() {
            // Morph hue over a 5-minute (300-second) cycle
            hue = (hue + (360 / 300)) % 360; 

            // FIX: Oscillate LIGHTNESS from 10% to 90%
            // This creates the "light and dark" effect.
            // (Sine wave oscillating over ~60 seconds)
            const lightnessOscillation = (Math.sin(Date.now() / 20000) + 1) / 2; // 0 to 1
            bgLight = 10 + (lightnessOscillation * 80); // 10% (dark) to 90% (light)
            
            // FIX: Guarantee readability by inverting lightness
            fontLight = (bgLight > 50) ? 10 : 90; 
            
            // FIX: Oscillate saturation for more variety
            bgSat = 30 + (lightnessOscillation * 40); // 30% to 70%
            fontSat = 70 + (1 - lightnessOscillation) * 20; // 70% to 90%

            // Apply the new target colors
            // The CSS transition will smoothly animate to these.
            body.style.setProperty('--bg-color', `hsl(${hue}, ${bgSat}%, ${bgLight}%)`);
            body.style.setProperty('--font-color', `hsl(${(hue + 180) % 360}, ${fontSat}%, ${fontLight}%)`);
            
            // Schedule the next morph step
            setTimeout(morphColors, 1000); 
        }

        /**
         * This function runs on a separate, accelerating interval
         * to handle the *instant* flash.
         */
        function flashLoop() {
            // Don't flash if Phase 2 isn't active
            // or if we're already in the middle of a flash
            if (!isFlashing || isCurrentlyFlashing) {
                // Schedule the next *check*
                setTimeout(flashLoop, flashInterval);
                return;
            }

            // --- START FLASH ---
            isCurrentlyFlashing = true;

            // Calculate the flash colors (opposite hue, same lightness)
            const flashBgHue = (hue + flashHueJump) % 360;
            const flashFontHue = hue;

            // 1. Add class to set 'transition: none'
            body.classList.add('is-flashing');
            
            // 2. Apply the instant flash color
            body.style.setProperty('--bg-color', `hsl(${flashBgHue}, ${bgSat}%, ${bgLight}%)`);
            body.style.setProperty('--font-color', `hsl(${flashFontHue}, ${fontSat}%, ${fontLight}%)`);

            // 3. Wait for the flash duration
            setTimeout(() => {
                // 4. Remove class to re-enable 'transition: 1.0s'
                body.classList.remove('is-flashing');
                
                /*
                  CRITICAL: We must re-apply the *morph* colors.
                  The browser will now smoothly animate from the
                  flash color *back* to the morph color.
                */
                body.style.setProperty('--bg-g-color', `hsl(${hue}, ${bgSat}%, ${bgLight}%)`);
                body.style.setProperty('--font-color', `hsl(${(hue + 180) % 360}, ${fontSat}%, ${fontLight}%)`);
                
                isCurrentlyFlashing = false;
                
                // 5. Schedule the next flash check
                setTimeout(flashLoop, flashInterval);
                
            }, FLASH_DURATION);
        }


        function accelerateFlashing() {
            // This function no longer runs on rAF
            // It just updates the 'flashInterval' variable
            flashAccelerationStartTime = Date.now();
            
            function updateFlashInterval() {
                const elapsedTime = Date.now() - flashAccelerationStartTime;
                const progress = Math.min(elapsedTime / FLASH_ACCELERATION_DURATION, 1);
                
                flashInterval = FLASH_INTERVAL_START + (FLASH_INTERVAL_END - FLASH_INTERVAL_START) * progress;
                
                if (progress < 1) {
                    requestAnimationFrame(updateFlashInterval);
                } else {
                    flashInterval = FLASH_INTERVAL_END; // Lock at max speed
                    console.log("--- Flashing at MAX speed ---");
                }
            }
            updateFlashInterval();
        }

        // --- START EVERYTHING ---
        
        /**
         * Main initialization function
         */
        async function main() {
            // Start the two independent loops
            setTimeout(morphColors, 1000); // Start the morph loop
            setTimeout(flashLoop, flashInterval); // Start the flash-check loop

            // 2. Load and parse the poems
            await loadAndParsePoems();
            
            // 3. If poems loaded, hide loading screen and start
            if (allPoems.length > 0) {
                loadingOverlay.classList.add('hidden');
                
                // Start timers for phases
                setTimeout(() => {
                    console.log("--- PHASE 2: Flashing Started ---");
                    isFlashing = true;
                    accelerateFlashing();
                }, PHASE_2_START_TIME);

                setTimeout(() => {
                    console.log("--- PHASE 3: Shiny Text Started ---");
                    isPhase3 = true;
                    body.classList.add('phase-3');
                }, PHASE_3_START_TIME);

                // Timer for Phase 4
                setTimeout(() => {
                    console.log("--- PHASE 4: Text Flicker Started ---");
                    body.classList.add('phase-4');
                }, PHASE_4_START_TIME);

                // Start the poem display
                startNewPoem();
            }
            // If poems didn't load, the error message will remain visible.
        }
        
        // Run the main function
        main();

    </script>
</body>
</html>
