<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dickinson Poems</title>
    
    <!-- FIX: Import "EB Garamond" font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">
    
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            
            /* FIX: Use EB Garamond as the primary font */
            font-family: "Felix Titling", "EB Garamond", serif;
            
            --bg-color: hsl(200, 30%, 10%);
            --font-color: hsl(20, 80%, 90%);
            
            background-color: var(--bg-color);
            color: var(--font-color);
        }
        
        #poem-container {
            display: grid;
            place-items: center;
            height: 100%;
            text-align: center;
            padding: 2rem;
            box-sizing: border-box;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #stanza-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        .poem-line {
            font-size: clamp(1.25rem, 2.5vw, 1.75rem);
            line-height: 1.6;
            min-height: 1.6em; /* Prevents layout jump */
            opacity: 0;
            transition: opacity 1.2s ease-in-out;
            
            width: 100%;
            overflow-wrap: break-word;
            white-space: normal;
            
            /* FIX: Use small-caps to "shrink lowercase" */
            font-variant: small-caps;
        }

        /* Style for the em-dash */
        .poem-line .em-dash {
            font-family: 'Times New Roman', Times, serif;
            font-weight: bold;
            font-variant: normal; /* Keep em-dash from shrinking */
        }

        /* Title Overlay for Roman Numeral */
        #poem-title-overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            
            background-color: var(--bg-color);
            color: var(--font-color);
            
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.2s ease-in-out;
        }
        
        #poem-title-numeral {
            font-size: clamp(3rem, 10vw, 5rem);
            font-weight: 700;
            transform: scale(0.9);
            opacity: 0;
            transition: opacity 1.2s ease-in-out, transform 1.2s ease-in-out;
            font-variant: normal; /* Keep title from shrinking */
        }

        #loading {
            font-size: 2rem;
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background-color: #000;
            color: #fff;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            font-family: 'Cinzel', serif; /* Keep Cinzel for loading */
        }
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Hide the poem container when the title is showing */
        body.showing-title #poem-container {
            opacity: 0;
        }

        /* --- PHASES FOR EFFECTS --- */
        @keyframes shine {
            to {
                background-position: -200% center;
            }
        }
        @keyframes flicker-bright {
            0%   { filter: brightness(1); }
            5%   { filter: brightness(0.5); }
            10%  { filter: brightness(1); }
            20%  { filter: brightness(1); }
            22%  { filter: brightness(0.3); }
            25%  { filter: brightness(1); }
            50%  { filter: brightness(1); }
            52%  { filter: brightness(0.6); }
            56%  { filter: brightness(1); }
            80%  { filter: brightness(1); }
            83%  { filter: brightness(0.4); }
            88%  { filter: brightness(1); }
            100% { filter: brightness(1); }
        }

        /* Phase 3: Activated after 15 minutes */
        body.phase-3 .poem-line {
            background-image: linear-gradient(
                -45deg,
                #ff0000, #ff7300, #48ff00,
                #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000
            );
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            
            text-shadow: 0 0 8px #fff, 0 0 12px #fff, 0 0 20px #fff;
            animation: shine 8s linear infinite;
        }
        
        /* Phase 4: Activated after 17 minutes */
        body.phase-4 .poem-line {
            /* Stack animations */
            animation: shine 8s linear infinite, 
                       flicker-bright 0.2s linear infinite;
        }

    </style>
</head>
<body>

    <div id="poem-container">
        <!-- 
          FIX: Stanza container is now empty.
          JS will dynamically add/remove lines here.
        -->
        <div id="stanza-container">
        </div>
    </div>

    <div id="loading">Loading Poems...</div>

    <div id="poem-title-overlay">
        <h1 id="poem-title-numeral"></h1>
    </div>

    <script>
        // --- POEM DATA ---
        let allPoems = [];

        // --- DOM REFERENCES ---
        const stanzaContainer = document.getElementById("stanza-container");
        const body = document.body;
        const titleOverlay = document.getElementById('poem-title-overlay');
        const titleNumeral = document.getElementById('poem-title-numeral');
        const loadingOverlay = document.getElementById('loading');

        // --- STATE VARIABLES ---
        let currentPoem = null;
        let currentStanzaIndex = 0;
        let isFlashingActive = false; // Phase 2 (accelerating morph)
        let isPhase3 = false;
        let flashAccelerationStartTime = 0;
        
        // --- TIMING CONSTANTS ---
        const LINE_FADE_IN = 1200;
        const LINE_FADE_OUT = 1200;
        const LINE_VISIBLE = 2500;
        const STANZA_DELAY = 1000;
        const POEM_DELAY = 2000;

        const PHASE_2_START_TIME = 5 * 60 * 1000;  // 5 minutes
        const FLASH_ACCELERATION_DURATION = 10 * 60 * 1000; // 10 minutes (5m -> 15m)
        
        const PHASE_3_START_TIME = 15 * 60 * 1000; // 15 minutes (Polychrome)
        const PHASE_4_START_TIME = 17 * 60 * 1000; // FIX: 17 minutes (Flicker)

        // Title Flash Timing
        const TIME_TITLE_FADE_IN = 1200;
        const TIME_TITLE_VISIBLE = 2000;
        const TIME_TITLE_FADE_OUT = 1200;

        // --- POEM DISPLAY LOGIC ---
        async function loadAndParsePoems() {
            try {
                const poemsUrl = 'https://MTvrimPossible.github.io/dickinson/dickinson.txt';
                const response = await fetch(poemsUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();

                const normalizedText = "\n\n" + text.replace(/\r\n/g, '\n');
                const parts = normalizedText.split(/\n\n([IVXLCDM]+)\.\n\n/);
                
                for (let i = 1; i < parts.length; i += 2) {
                    const title = parts[i];
                    const poemText = parts[i + 1];
                    if (!poemText) continue;

                    const lines = poemText.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);

                    // FIX: Stanzas are now chunks of lines, not just 4
                    const stanzas = [];
                    let currentStanza = [];
                    for (const line of lines) {
                        currentStanza.push(line);
                        // This assumes 4-line stanzas. A better parser
                        // would detect blank lines between stanzas.
                        // But for now, let's stick to 4-line chunks.
                        // Let's refine this: We will use the user's "by chunk"
                        // logic. We assume stanzas are separated by blank lines
                        // in the text file, which the .filter() removes.
                        // A better way: split by empty lines *before* filtering.
                    }
                    
                    // --- RE-PARSING STANZAS ---
                    // Let's assume stanzas are 4 lines *unless*
                    // we re-parse to find blank lines.
                    // The user's TXT file shows 4-line stanzas.
                    // The "some are shorter" is the key.
                    // The .split('\n') and .filter() logic is the bug.
                    
                    // Let's reset.
                    allPoems = []; // Clear array
                    const poemBlocks = normalizedText.split(/\n\n([IVXLCDM]+)\.\n\n/);

                    for (let i = 1; i < poemBlocks.length; i += 2) {
                        const title = poemBlocks[i];
                        const poemText = poemBlocks[i+1];
                        if (!poemText) continue;

                        // Split poem text into stanzas (blocks separated by blank lines)
                        const stanzaStrings = poemText.trim().split(/\n\s*\n/);
                        
                        const stanzas = stanzaStrings.map(stanzaStr => {
                            // Split stanza block into individual lines
                            return stanzaStr.split('\n')
                                .map(line => line.trim()) // Trim whitespace
                                .filter(line => line.length > 0); // Remove empty
                        }).filter(stanza => stanza.length > 0); // Remove empty stanzas

                        if (stanzas.length > 0) {
                            allPoems.push({
                                title: title,
                                stanzas: stanzas
                            });
                        }
                    }
                }
                
                if (allPoems.length === 0) {
                    throw new Error("No poems were successfully parsed. Check file format.");
                }
                
                console.log(`Successfully loaded and parsed ${allPoems.length} poems.`);
                
            } catch (error) {
                console.error("Failed to load or parse poems:", error.message, error);
                loadingOverlay.textContent = "Error loading poems. Please try again.";
            }
        }


        async function startNewPoem() {
            let newPoem;
            do {
                newPoem = allPoems[Math.floor(Math.random() * allPoems.length)];
            } while (newPoem === currentPoem && allPoems.length > 1);
            
            currentPoem = newPoem;
            currentStanzaIndex = 0;
            
            await displayPoemTitle(currentPoem.title);
            showStanza(currentStanzaIndex);
        }

        async function displayPoemTitle(titleString) {
            titleNumeral.textContent = titleString; 
            
            body.classList.add('showing-title');
            titleOverlay.style.pointerEvents = 'auto';
            titleOverlay.style.opacity = 1;

            await wait(100);
            titleNumeral.style.opacity = 1;
            titleNumeral.style.transform = 'scale(1)';

            await wait(TIME_TITLE_VISIBLE);

            titleOverlay.style.opacity = 0;
            titleNumeral.style.opacity = 0;
            titleNumeral.style.transform = 'scale(0.9)';
            
            await wait(TIME_TITLE_FADE_OUT);
            
            body.classList.remove('showing-title');
            titleOverlay.style.pointerEvents = 'none';
        }

        /**
         * Displays a single stanza, line by line.
         */
        async function showStanza(stanzaIndex) {
            const stanza = currentPoem.stanzas[stanzaIndex];
            
            // FIX: Clear old stanza lines
            stanzaContainer.innerHTML = '';
            const lineElements = []; // Create a new list of elements

            // FIX: Create exactly as many lines as are in the stanza
            for (const lineText of stanza) {
                const el = document.createElement('div');
                el.className = 'poem-line';
                stanzaContainer.appendChild(el);
                lineElements.push(el);
            }

            for (let i = 0; i < lineElements.length; i++) {
                const line = stanza[i] || "";
                const el = lineElements[i];
                
                // --- Font shrinking/wrapping logic ---
                el.style.fontSize = ''; 
                
                const processedLine = line.replace(/\s*-\s*/g, '<span class="em-dash">â€”</span>');
                el.innerHTML = processedLine;

                const containerWidth = stanzaContainer.clientWidth;

                if (el.scrollWidth > containerWidth) {
                    const defaultFontSize = parseFloat(window.getComputedStyle(el).fontSize);
                    const ratio = containerWidth / el.scrollWidth;
                    const newFontSize = Math.floor(defaultFontSize * ratio); 
                    el.style.fontSize = `${newFontSize}px`;
                    const _ = el.offsetWidth; // Force reflow
                }
                // CSS 'white-space: normal' will wrap as fallback
                // --- End of new logic ---
                
                el.style.opacity = 1;
                await wait(LINE_VISIBLE);
                
                el.style.opacity = 0;
                await wait(LINE_FADE_OUT);
            }

            await wait(STANZA_DELAY);

            if (currentStanzaIndex < currentPoem.stanzas.length - 1) {
                currentStanzaIndex++;
                showStanza(currentStanzaIndex);
            } else {
                await wait(POEM_DELAY);
                startNewPoem();
            }
        }
        
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- COLOR & EFFECT LOGIC ---
        
        let hue = 200;
        let bgLight = 10;
        let fontLight = 90;
        let bgSat = 30;
        let fontSat = 80;
        const flashHueJump = 180;
        let lastTimestamp = 0;

        // FIX: Hue morph speeds.
        // Start: 5-minute cycle (300,000 ms)
        const HUE_MORPH_SPEED_START = 360 / 300000; // degrees per ms
        // End: 1-second cycle (1,000 ms)
        const HUE_MORPH_SPEED_END = 360 / 1000;     // degrees per ms
        
        // This variable will be accelerated
        let currentHueMorphSpeed = HUE_MORPH_SPEED_START;
        
        // Lightness oscillates over 60 seconds (60,000 ms)
        const LIGHTNESS_OSC_SPEED = Math.PI * 2 / 60000; // radians per ms

        function colorLoop(timestamp) {
            if (lastTimestamp === 0) {
                lastTimestamp = timestamp;
            }
            // Cap delta time to 100ms to prevent jumps
            let deltaTime = Math.min(timestamp - lastTimestamp, 100);
            lastTimestamp = timestamp;

            // --- 1. HANDLE MORPH STATE ---
            // FIX: Use the new 'currentHueMorphSpeed'
            hue = (hue + (currentHueMorphSpeed * deltaTime)) % 360; 

            // Oscillate Lightness (10% to 90%)
            const lightnessOscillation = (Math.sin(timestamp * LIGHTNESS_OSC_SPEED) + 1) / 2;
            bgLight = 10 + (lightnessOscillation * 80);
            fontLight = (bgLight > 50) ? 10 : 90;
            
            // Oscillate Saturation
            bgSat = 30 + (lightnessOscillation * 40);
            fontSat = 70 + (1 - lightnessOscillation) * 20;
            
            // Apply Morph Colors
            body.style.setProperty('--bg-color', `hsl(${hue}, ${bgSat}%, ${bgLight}%)`);
            body.style.setProperty('--font-color', `hsl(${(hue + 180) % 360}, ${fontSat}%, ${fontLight}%)`);
            
            // Loop forever
            requestAnimationFrame(colorLoop);
        }

        // FIX: This function now accelerates the MORPH SPEED
        function accelerateFlashing() {
            flashAccelerationStartTime = Date.now();
            
            function updateFlashSpeed() {
                const elapsedTime = Date.now() - flashAccelerationStartTime;
                const progress = Math.min(elapsedTime / FLASH_ACCELERATION_DURATION, 1);
                
                // Interpolate the morph speed
                currentHueMorphSpeed = HUE_MORPH_SPEED_START + 
                                     (HUE_MORPH_SPEED_END - HUE_MORPH_SPEED_START) * progress;
                
                if (progress < 1) {
                    requestAnimationFrame(updateFlashSpeed);
                } else {
                    currentHueMorphSpeed = HUE_MORPH_SPEED_END; // Lock at max speed
                    console.log("--- Flashing at MAX speed ---");
                }
            }
            updateFlashSpeed();
        }

        // --- START EVERYTHING ---
        
        async function main() {
            // Start the single, all-in-one animation loop
            requestAnimationFrame(colorLoop);

            await loadAndParsePoems();
            
            if (allPoems.length > 0) {
                loadingOverlay.classList.add('hidden');
                
                setTimeout(() => {
                    console.log("--- PHASE 2: Accelerating Morph Started ---");
                    isFlashingActive = true;
                    // FIX: Call the correct function
                    accelerateFlashing();
                }, PHASE_2_START_TIME);

                setTimeout(() => {
                    console.log("--- PHASE 3: Shiny Text Started ---");
                    isPhase3 = true;
                    body.classList.add('phase-3');
                }, PHASE_3_START_TIME);

                // FIX: Phase 4 starts at 17 minutes
                setTimeout(() => {
                    console.log("--- PHASE 4: Text Flicker Started ---");
                    body.classList.add('phase-4');
                }, PHASE_4_START_TIME);

                startNewPoem();
            }
        }
        
        main();

    </script>
</body>
</html>
